<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>MusicXML Import Test</title>
  <style>body{font-family:system-ui,Segoe UI,Arial;margin:20px;background:#f7fafc;color:#0f172a}pre{background:#fff;padding:12px;border-radius:6px;box-shadow:0 1px 2px rgba(0,0,0,.05);overflow:auto}</style>
</head>
<body>
  <h1>MusicXML Import Test</h1>
  <p>This page runs the CreateExercise parser against the provided MusicXML and shows results.</p>
  <div id="result"></div>
  <pre id="out"></pre>

<script type="module">
// --- parser helpers (port of CreateExercise.vue parseMusicXML) ---
function typeToToken(type, dots = 0) {
  let base = "";
  switch (type) {
    case "whole": base = "w"; break;
    case "half": base = "h"; break;
    case "quarter": base = "q"; break;
    case "eighth": base = "e"; break;
    case "16th": base = "s"; break;
    default: break;
  }
  if (!base) return "";
  return dots > 0 ? base + "." : base;
}
function toSpn(step, alter, octave) {
  if (!step) return "";
  let acc = "";
  if (alter === 1) acc = "#";
  else if (alter === -1) acc = "b";
  else if (alter > 1) acc = "##";
  else if (alter < -1) acc = "bb";
  return `${step}${acc}${octave}`;
}
function fifthsToKey(f) {
  const map = {"-7":"Cb major","-6":"Gb major","-5":"Db major","-4":"Ab major","-3":"Eb major","-2":"Bb major","-1":"F major",0:"C major",1:"G major",2:"D major",3:"A major",4:"E major",5:"B major",6:"F# major",7:"C# major"};
  return map[String(Number.isNaN(f) ? 0 : f)] || "C major";
}

function parseMusicXML(xmlText) {
  const doc = new DOMParser().parseFromString(xmlText, "application/xml");
  if (doc.getElementsByTagName("parsererror").length) throw new Error("Invalid XML");
  const pick = (sel) => doc.querySelector(sel)?.textContent?.trim() || "";
  const title = pick("work > work-title") || pick("movement-title") || "";
  const fifthsStr = pick("part measure attributes key fifths");
  const ks = fifthsToKey(Number.parseInt(fifthsStr || "0", 10));
  const beats = pick("part measure attributes time beats") || "4";
  const beatType = pick("part measure attributes time beat-type") || "4";
  const timeSig = `${beats}/${beatType}`;

  const part = doc.querySelector("score-partwise > part");
  const notesOut = [];
  if (part) {
    const noteNodes = part.querySelectorAll("measure > note");
    for (let i = 0; i < noteNodes.length; i++) {
      const n = noteNodes[i];
      if (n.querySelector("rest")) {
        const type = n.querySelector("type")?.textContent?.trim() || "quarter";
        const dots = n.querySelectorAll("dot").length;
        const dur = typeToToken(type, dots);
        if (dur) notesOut.push({ pitch: "B/4", duration: dur + "r" });
        continue;
      }
      const group = [n];
      let j = i + 1;
      while (j < noteNodes.length && noteNodes[j].querySelector("chord")) { group.push(noteNodes[j]); j++; }
      if (group.length > 1) {
        let best = null; let bestValue = -Infinity;
        for (const gn of group) {
          if (gn.querySelector("rest")) continue;
          const step = gn.querySelector("pitch > step")?.textContent?.trim() || "";
          const alter = Number.parseInt(gn.querySelector("pitch > alter")?.textContent?.trim() || "0", 10);
          const octave = Number.parseInt(gn.querySelector("pitch > octave")?.textContent?.trim() || "4", 10);
          if (!step) continue;
          const stepMap = { C:0,D:2,E:4,F:5,G:7,A:9,B:11 };
          const base = stepMap[step.toUpperCase()] ?? 0;
          const semitone = base + (Number.isFinite(alter) ? alter : 0);
          const value = octave * 12 + semitone;
          if (value > bestValue) { bestValue = value; best = { gn, step, alter, octave }; }
        }
        i = j - 1;
        if (best) {
          const type = best.gn.querySelector("type")?.textContent?.trim() || "quarter";
          const dots = best.gn.querySelectorAll("dot").length;
          const dur = typeToToken(type, dots);
          const spn = toSpn(best.step, best.alter, String(best.octave));
          if (spn && dur) notesOut.push({ pitch: spn, duration: dur, noteColor: "orange" });
        }
        continue;
      }
      const step = n.querySelector("pitch > step")?.textContent?.trim() || "";
      const alter = Number.parseInt(n.querySelector("pitch > alter")?.textContent?.trim() || "0", 10);
      const octave = n.querySelector("pitch > octave")?.textContent?.trim() || "4";
      const type = n.querySelector("type")?.textContent?.trim() || "quarter";
      const spn = toSpn(step, alter, octave);
      const dots = n.querySelectorAll("dot").length;
      const dur = typeToToken(type, dots);
      if (spn && dur) notesOut.push({ pitch: spn, duration: dur });
    }
  }
  return { title, keySignature: ks, timeSignature: timeSig, noteArray: notesOut };
}

// Prefer loading the sample XML file if present (tools/sample-musicxml.xml)
let xmlText = null;
async function loadSampleXml() {
  try {
    const resp = await fetch('/tools/sample-musicxml.xml');
    if (!resp.ok) return null;
    return await resp.text();
  } catch (e) {
    return null;
  }
}

// load sample xml if available, otherwise fall back to the embedded snippet
await (async () => {
  const fetched = await loadSampleXml();
  if (fetched) xmlText = fetched;
  else xmlText = `<?xml version="1.0" encoding="UTF-8"?>\n<score-partwise version="4.0">\n  <part id="P1">\n    <measure number="1">\n      <note>\n        <pitch><step>C</step><octave>4</octave></pitch>\n        <duration>4</duration>\n        <type>quarter</type>\n      </note>\n    </measure>\n  </part>\n</score-partwise>`;
})();

try {
  const parsed = parseMusicXML(xmlText);
  const out = document.getElementById('out');
  const result = document.getElementById('result');
  if (!parsed.noteArray || parsed.noteArray.length === 0) {
    result.innerHTML = '<strong style="color:#b91c1c">No playable notes found in MusicXML.</strong>';
  } else {
    result.innerHTML = `<strong style="color:#065f46">Parsed ${parsed.noteArray.length} tokens</strong>`;
  }
  out.textContent = JSON.stringify(parsed, null, 2);
  console.log('Parsed', parsed);
} catch (e) {
  document.getElementById('out').textContent = 'Error parsing XML: ' + e;
}
</script>
</body>
</html>